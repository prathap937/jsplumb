## API Report File for "@jsplumb/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AnchorPlacement } from '@jsplumb/common';
import { AnchorSpec } from '@jsplumb/common';
import { ArrowOverlayOptions } from '@jsplumb/common';
import { BoundingBox } from '@jsplumb/util';
import { Connector } from '@jsplumb/common';
import { ConnectorOptions } from '@jsplumb/common';
import { ConnectorSpec } from '@jsplumb/common';
import { EndpointRepresentationParams } from '@jsplumb/common';
import { EndpointSpec } from '@jsplumb/common';
import { EndpointStyle } from '@jsplumb/common';
import { EventGenerator } from '@jsplumb/util';
import { Extents } from '@jsplumb/util';
import { FullOverlaySpec } from '@jsplumb/common';
import { Geometry } from '@jsplumb/common';
import { Merge } from '@jsplumb/util';
import { OverlayOptions } from '@jsplumb/common';
import { OverlaySpec } from '@jsplumb/common';
import { PaintAxis } from '@jsplumb/common';
import { PaintStyle } from '@jsplumb/common';
import { PerimeterAnchorShapes } from '@jsplumb/common';
import { PointNearPath } from '@jsplumb/common';
import { PointXY } from '@jsplumb/util';
import { RotatedPointXY } from '@jsplumb/util';
import { Rotations } from '@jsplumb/util';
import { Segment } from '@jsplumb/common';
import { SegmentParams } from '@jsplumb/common';
import { Size } from '@jsplumb/util';

// @public (undocumented)
export const ABSOLUTE = "absolute";

// @public (undocumented)
export interface AbstractSelectOptions<E> {
    // (undocumented)
    scope?: SelectionList;
    // (undocumented)
    source?: ElementSelectionSpecifier<E>;
    // (undocumented)
    target?: ElementSelectionSpecifier<E>;
}

// @public (undocumented)
export const ADD_CLASS_ACTION = "add";

// @public (undocumented)
export interface AddGroupOptions<E> extends GroupOptions {
    // (undocumented)
    collapsed?: boolean;
    // (undocumented)
    el: E;
}

// Warning: (ae-incompatible-release-tags) The symbol "_addSegment" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public (undocumented)
export function _addSegment<T extends SegmentParams>(connector: ConnectorBase, segmentType: string, params: T): void;

// Warning: (ae-internal-missing-underscore) The name "AnchorComputeParams" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type AnchorComputeParams = {
    xy?: PointXY;
    wh?: Size;
    txy?: PointXY;
    twh?: Size;
    element?: Endpoint;
    timestamp?: string;
    index?: number;
    tElement?: Endpoint;
    connection?: Connection;
    elementId?: string;
    rotation?: Rotations;
    tRotation?: Rotations;
};

// @public (undocumented)
export type AnchorOrientationHint = -1 | 0 | 1;

// Warning: (ae-internal-missing-underscore) The name "AnchorRecord" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface AnchorRecord {
    // (undocumented)
    cls: string;
    // (undocumented)
    iox: AnchorOrientationHint;
    // (undocumented)
    ioy: AnchorOrientationHint;
    // (undocumented)
    offx: number;
    // (undocumented)
    offy: number;
    // (undocumented)
    ox: AnchorOrientationHint;
    // (undocumented)
    oy: AnchorOrientationHint;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// Warning: (ae-internal-missing-underscore) The name "ArcSegment" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface ArcSegment extends Segment {
    // (undocumented)
    anticlockwise: boolean;
    // (undocumented)
    circumference: number;
    // (undocumented)
    cx: number;
    // (undocumented)
    cy: number;
    // (undocumented)
    endAngle: number;
    // (undocumented)
    frac: number;
    // (undocumented)
    length: number;
    // (undocumented)
    radius: number;
    // (undocumented)
    startAngle: number;
    // (undocumented)
    sweep: number;
}

// Warning: (ae-internal-missing-underscore) The name "ArcSegmentParams" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface ArcSegmentParams extends SegmentParams {
    // (undocumented)
    ac: boolean;
    // (undocumented)
    cx: number;
    // (undocumented)
    cy: number;
    // (undocumented)
    endAngle?: number;
    // (undocumented)
    r: number;
    // (undocumented)
    startAngle?: number;
}

// @public (undocumented)
export interface ArrowOverlay extends OverlayBase {
    // (undocumented)
    cachedDimensions: Size;
    // (undocumented)
    direction: number;
    // (undocumented)
    foldback: number;
    // (undocumented)
    length: number;
    // (undocumented)
    location: number;
    // (undocumented)
    paintStyle: PaintStyle;
    // (undocumented)
    width: number;
}

// @public (undocumented)
export const ArrowOverlayHandler: OverlayHandler<ArrowOverlayOptions>;

// @public (undocumented)
export function att(...attName: Array<string>): string;

// @public (undocumented)
export const ATTRIBUTE_GROUP = "data-jtk-group";

// @public (undocumented)
export const ATTRIBUTE_MANAGED = "data-jtk-managed";

// @public (undocumented)
export const ATTRIBUTE_NOT_DRAGGABLE = "data-jtk-not-draggable";

// @public (undocumented)
export const ATTRIBUTE_SCOPE = "data-jtk-scope";

// @public (undocumented)
export const ATTRIBUTE_SCOPE_PREFIX: string;

// @public (undocumented)
export const ATTRIBUTE_TABINDEX = "tabindex";

// @public (undocumented)
export type Axis = [Face, Face];

// @public
export type BeforeDetachInterceptor = (c: Connection) => boolean;

// @public
export type BeforeDragInterceptor<E = any> = (params: BeforeDragParams<E>) => boolean | Record<string, any>;

// @public
export interface BeforeDragParams<E> {
    // (undocumented)
    connection: Connection;
    // (undocumented)
    endpoint: Endpoint;
    // (undocumented)
    source: E;
    // (undocumented)
    sourceId: string;
}

// @public
export type BeforeDropInterceptor = (params: BeforeDropParams) => boolean;

// @public
export interface BeforeDropParams {
    // (undocumented)
    connection: Connection;
    // (undocumented)
    dropEndpoint: Endpoint;
    // (undocumented)
    scope: string;
    // (undocumented)
    sourceId: string;
    // (undocumented)
    targetId: string;
}

// @public
export type BeforeStartDetachInterceptor<E = any> = (params: BeforeStartDetachParams<E>) => boolean;

// @public
export interface BeforeStartDetachParams<E> extends BeforeDragParams<E> {
}

// @public
export interface BehaviouralTypeDescriptor<T = any> extends EndpointTypeDescriptor {
    allowLoopback?: boolean;
    anchorPositionFinder?: (el: Element, elxy: PointXY, def: BehaviouralTypeDescriptor, e: Event) => AnchorSpec | null;
    canAcceptNewConnection?: (el: Element, e: Event) => boolean;
    edgeType?: string;
    extract?: Record<string, string>;
    onMaxConnections?: (value: any, event?: any) => any;
    parameterExtractor?: (el: T, eventTarget: T, event: Event) => Record<string, any>;
    parentSelector?: string;
    portId?: string;
    rank?: number;
    redrop?: RedropPolicy;
    source?: boolean;
    target?: boolean;
    uniqueEndpoint?: boolean;
}

// @public (undocumented)
export interface BlankEndpoint extends EndpointRepresentation<ComputedBlankEndpoint> {
}

// @public (undocumented)
export const BlankEndpointHandler: EndpointHandler<BlankEndpoint, ComputedBlankEndpoint>;

// @public (undocumented)
export const BLOCK = "block";

// @public (undocumented)
export const BOTTOM = FaceValues.bottom;

// @public (undocumented)
export const CHECK_CONDITION = "checkCondition";

// @public (undocumented)
export const CHECK_DROP_ALLOWED = "checkDropAllowed";

// @public (undocumented)
export const CLASS_CONNECTED = "jtk-connected";

// @public (undocumented)
export const CLASS_CONNECTOR = "jtk-connector";

// @public (undocumented)
export const CLASS_CONNECTOR_OUTLINE = "jtk-connector-outline";

// @public (undocumented)
export const CLASS_ENDPOINT = "jtk-endpoint";

// @public (undocumented)
export const CLASS_ENDPOINT_ANCHOR_PREFIX = "jtk-endpoint-anchor";

// @public (undocumented)
export const CLASS_ENDPOINT_CONNECTED = "jtk-endpoint-connected";

// @public (undocumented)
export const CLASS_ENDPOINT_DROP_ALLOWED = "jtk-endpoint-drop-allowed";

// @public (undocumented)
export const CLASS_ENDPOINT_DROP_FORBIDDEN = "jtk-endpoint-drop-forbidden";

// @public (undocumented)
export const CLASS_ENDPOINT_FLOATING = "jtk-floating-endpoint";

// @public (undocumented)
export const CLASS_ENDPOINT_FULL = "jtk-endpoint-full";

// @public (undocumented)
export const CLASS_GROUP_COLLAPSED = "jtk-group-collapsed";

// @public (undocumented)
export const CLASS_GROUP_EXPANDED = "jtk-group-expanded";

// @public (undocumented)
export const CLASS_OVERLAY = "jtk-overlay";

// Warning: (ae-internal-missing-underscore) The name "ClassAction" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ClassAction = typeof ADD_CLASS_ACTION | typeof REMOVE_CLASS_ACTION;

// @public (undocumented)
export function classList(...className: Array<string>): string;

// Warning: (ae-incompatible-release-tags) The symbol "_clearSegments" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public (undocumented)
export function _clearSegments(connector: ConnectorBase): void;

// @public (undocumented)
export function cls(...className: Array<string>): string;

// @public (undocumented)
export interface Component {
    // (undocumented)
    beforeDetach: BeforeDetachInterceptor;
    // (undocumented)
    beforeDrop: BeforeDropInterceptor;
    // (undocumented)
    cssClass: string;
    // (undocumented)
    data: Record<string, any>;
    // Warning: (ae-incompatible-release-tags) The symbol "_defaultType" is marked as @public, but its signature references "ComponentTypeDescriptor" which is marked as @internal
    //
    // (undocumented)
    _defaultType: ComponentTypeDescriptor;
    // (undocumented)
    deleted: boolean;
    // (undocumented)
    getDefaultOverlayKey(): string;
    // (undocumented)
    getIdPrefix(): string;
    // (undocumented)
    getXY(): PointXY;
    // (undocumented)
    _hover: boolean;
    // (undocumented)
    hoverClass: string;
    // (undocumented)
    hoverPaintStyle: PaintStyle;
    // (undocumented)
    id: string;
    // (undocumented)
    instance: JsPlumbInstance;
    // (undocumented)
    lastPaintedAt: string;
    // (undocumented)
    overlayPlacements: Record<string, Extents>;
    // (undocumented)
    overlayPositions: Record<string, PointXY>;
    // (undocumented)
    overlays: Record<string, OverlayBase>;
    // (undocumented)
    paintStyle: PaintStyle;
    // (undocumented)
    paintStyleInUse: PaintStyle;
    // (undocumented)
    parameters: ComponentParameters;
    // (undocumented)
    params: Record<string, any>;
    // (undocumented)
    _typeCache: {};
    // (undocumented)
    _typeDescriptor: string;
    // (undocumented)
    _types: Set<string>;
    // (undocumented)
    visible: boolean;
}

// Warning: (ae-internal-missing-underscore) The name "ComponentOptions" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface ComponentOptions {
    // (undocumented)
    beforeDetach?: BeforeDetachInterceptor;
    // (undocumented)
    beforeDrop?: BeforeDropInterceptor;
    // (undocumented)
    cssClass?: string;
    // (undocumented)
    data?: any;
    // (undocumented)
    hoverClass?: string;
    // (undocumented)
    id?: string;
    // (undocumented)
    label?: string;
    // (undocumented)
    labelLocation?: number;
    // (undocumented)
    overlays?: Array<OverlaySpec>;
    // (undocumented)
    parameters?: Record<string, any>;
    // (undocumented)
    scope?: string;
}

// @public (undocumented)
export type ComponentParameters = Record<string, any>;

// @public (undocumented)
export const Components: {
    applyType(component: Component, t: any, params?: any): void;
    applyBaseType(component: Component, t: any, params?: any): void;
    destroy(component: Component): void;
    _setComponentVisible(component: Component, v: boolean): void;
    setVisible(component: Component, v: boolean): void;
    addBaseClass(component: Component, clazz: string, cascade?: boolean): void;
    removeBaseClass(component: Component, clazz: string, cascade?: boolean): void;
    addClass(component: Component, clazz: string, cascade?: boolean): void;
    removeClass(component: Component, clazz: string, cascade?: boolean): void;
    showOverlays(component: Component, ...ids: Array<string>): void;
    hideOverlays(component: Component, ...ids: Array<string>): void;
    setPaintStyle(component: Component, style: PaintStyle): void;
    setHoverPaintStyle(component: Component, style: PaintStyle): void;
    mergeParameters(component: Component, p: ComponentParameters): void;
    addOverlay(component: Component, overlay: OverlaySpec): OverlayBase;
    getOverlay<T extends OverlayBase>(component: Component, id: string): T;
    hideOverlay(component: Component, id: string): void;
    showOverlay(component: Component, id: string): void;
    removeAllOverlays(component: Component): void;
    removeOverlay(component: Component, overlayId: string, dontCleanup?: boolean): void;
    removeOverlays(component: Component, ...overlays: string[]): void;
    getLabel(component: Component): string;
    getLabelOverlay(component: Component): LabelOverlay;
    setLabel(component: Component, l: string | Function | LabelOverlay): void;
    getDefaultType(component: Component): ComponentTypeDescriptor;
    appendToDefaultType(component: Component, obj: Record<string, any>): void;
    cacheTypeItem(component: Component, key: string, item: any, typeId: string): void;
    getCachedTypeItem(component: Component, key: string, typeId: string): any;
    setType(component: Component, typeId: string, params?: any): void;
    getType(component: Component): string[];
    reapplyTypes(component: Component, params?: any): void;
    hasType(component: Component, typeId: string): boolean;
    addType(component: Component, typeId: string, params?: any): void;
    removeType(component: Component, typeId: string, params?: any): void;
    clearTypes(component: Component, params?: any): void;
    toggleType(component: Component, typeId: string, params?: any): void;
    isDetachAllowed(component: Component, connection: Connection): boolean;
    isDropAllowed(component: Component, sourceId: string, targetId: string, scope: string, connection: Connection, dropEndpoint: Endpoint): boolean;
    getData(component: Component): Record<string, any>;
    setData(component: Component, d: any): void;
    mergeData(component: Component, d: any): void;
    setAbsoluteOverlayPosition(component: Component, overlay: OverlayBase, xy: PointXY): void;
    getAbsoluteOverlayPosition(component: Component, overlay: OverlayBase): PointXY;
};

// Warning: (ae-internal-missing-underscore) The name "ComponentTypeDescriptor" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface ComponentTypeDescriptor extends TypeDescriptorBase {
    // (undocumented)
    overlays: Record<string, OverlaySpec>;
}

// Warning: (ae-incompatible-release-tags) The symbol "compute" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public (undocumented)
export function compute(connector: ConnectorBase, params: ConnectorComputeParams): void;

// @public (undocumented)
export type ComputedBlankEndpoint = [number, number, number, number];

// @public (undocumented)
export type ComputedDotEndpoint = [number, number, number, number, number];

// Warning: (ae-internal-missing-underscore) The name "ComputedPosition" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface ComputedPosition {
    // (undocumented)
    curX: number;
    // (undocumented)
    curY: number;
    // (undocumented)
    ox: AnchorOrientationHint;
    // (undocumented)
    oy: AnchorOrientationHint;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @public (undocumented)
export type ComputedRectangleEndpoint = [number, number, number, number];

// @public
export interface Connection<E = any> extends Component {
    // Warning: (ae-incompatible-release-tags) The symbol "connector" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
    //
    // (undocumented)
    connector: ConnectorBase;
    cost: number;
    // (undocumented)
    defaultLabelLocation: number;
    // (undocumented)
    defaultOverlayKey: string;
    // (undocumented)
    deleted: boolean;
    detachable: boolean;
    directed: boolean;
    // (undocumented)
    endpointHoverStyle: PaintStyle;
    // (undocumented)
    readonly endpointHoverStyles: [PaintStyle, PaintStyle];
    endpoints: [Endpoint, Endpoint];
    // (undocumented)
    readonly endpointSpec: EndpointSpec;
    // (undocumented)
    readonly endpointsSpec: [EndpointSpec, EndpointSpec];
    // (undocumented)
    endpointStyle: PaintStyle;
    // (undocumented)
    endpointStyles: [PaintStyle, PaintStyle];
    // @internal (undocumented)
    _forceDetach: boolean;
    // @internal (undocumented)
    _forceReattach: boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    idPrefix: string;
    // (undocumented)
    lastPaintedAt: string;
    // (undocumented)
    paintStyleInUse: PaintStyle;
    // @internal (undocumented)
    pending: boolean;
    // (undocumented)
    previousConnection: Connection<E>;
    // @internal
    proxies: Array<{
        ep: Endpoint;
        originalEp: Endpoint;
    }>;
    reattach: boolean;
    // (undocumented)
    scope: string;
    source: E;
    sourceId: string;
    // @internal (undocumented)
    suspendedElement: E;
    // @internal (undocumented)
    suspendedElementId: string;
    // @internal (undocumented)
    suspendedElementType: string;
    // @internal (undocumented)
    suspendedEndpoint: Endpoint;
    // @internal (undocumented)
    suspendedIndex: number;
    target: E;
    targetId: string;
    // (undocumented)
    typeId: string;
    readonly uuids: [string, string];
}

// @public
export interface ConnectionDetachedParams<E = any> extends ConnectionEstablishedParams<E> {
}

// @public (undocumented)
export class ConnectionDragSelector {
    constructor(selector: string, def: SourceOrTargetDefinition, exclude?: boolean);
    // (undocumented)
    def: SourceOrTargetDefinition;
    // (undocumented)
    exclude: boolean;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    isEnabled(): boolean;
    // (undocumented)
    redrop: RedropPolicy;
    // (undocumented)
    selector: string;
    // (undocumented)
    setEnabled(enabled: boolean): void;
}

// @public
export interface ConnectionEstablishedParams<E = any> {
    // (undocumented)
    connection: Connection;
    // (undocumented)
    source: E;
    // (undocumented)
    sourceEndpoint: Endpoint;
    // (undocumented)
    sourceId: string;
    // (undocumented)
    target: E;
    // (undocumented)
    targetEndpoint: Endpoint;
    // (undocumented)
    targetId: string;
}

// @public
export interface ConnectionMovedParams<E = any> {
    // (undocumented)
    connection: Connection<E>;
    // (undocumented)
    index: number;
    // (undocumented)
    newEndpoint: Endpoint;
    // (undocumented)
    newSourceId: string;
    // (undocumented)
    newTargetId: string;
    // (undocumented)
    originalEndpoint: Endpoint;
    // (undocumented)
    originalSourceId: string;
    // (undocumented)
    originalTargetId: string;
}

// Warning: (ae-internal-missing-underscore) The name "ConnectionOptions" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type ConnectionOptions<E = any> = Merge<ConnectParams<E>, {
    source?: E;
    target?: E;
    sourceEndpoint?: Endpoint;
    targetEndpoint?: Endpoint;
    previousConnection?: Connection;
    geometry?: any;
}>;

// Warning: (ae-internal-missing-underscore) The name "Connections" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const Connections: {
    isReattach(connection: Connection, alsoCheckForced: boolean): boolean;
    isDetachable(connection: Connection, ep?: Endpoint): boolean;
    setDetachable(connection: Connection, detachable: boolean): void;
    setReattach(connection: Connection, reattach: boolean): void;
    prepareConnector(connection: Connection, connectorSpec: ConnectorSpec, typeId?: string): ConnectorBase;
    setConnector(connection: Connection, connectorSpec: ConnectorSpec, doNotRepaint?: boolean, doNotChangeListenerComponent?: boolean, typeId?: string): void;
    getUuids(connection: Connection): [string, string];
    replaceEndpoint(connection: Connection, idx: number, endpointDef: EndpointSpec): void;
    makeEndpoint(connection: Connection, isSource: boolean, el: any, elId: string, anchor?: AnchorSpec, ep?: Endpoint): Endpoint;
    applyType(connection: Connection, t: ConnectionTypeDescriptor, typeMap: any): void;
    destroy(connection: Connection): void;
    setVisible(connection: Connection, v: boolean): void;
    addClass(connection: Connection, c: string, cascade?: boolean): void;
    removeClass(connection: Connection, c: string, cascade?: boolean): void;
    isConnection(component: any): component is Connection<any>;
    create(instance: JsPlumbInstance, params: ConnectionOptions): Connection;
};

// Warning: (ae-forgotten-export) The symbol "SelectionBase" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class ConnectionSelection extends SelectionBase<Connection> {
    // (undocumented)
    deleteAll(): void;
    // (undocumented)
    repaint(): ConnectionSelection;
    // (undocumented)
    setConnector(spec: ConnectorSpec): ConnectionSelection;
    // (undocumented)
    setDetachable(d: boolean): ConnectionSelection;
    // (undocumented)
    setReattach(d: boolean): ConnectionSelection;
}

// @public
export interface ConnectionTypeDescriptor extends TypeDescriptor {
    detachable?: boolean;
    endpoints?: [EndpointSpec, EndpointSpec];
    reattach?: boolean;
}

// @public (undocumented)
export const CONNECTOR_TYPE_STRAIGHT = "Straight";

// Warning: (ae-internal-missing-underscore) The name "ConnectorBase" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface ConnectorBase extends Connector {
    // (undocumented)
    bounds: Extents;
    // (undocumented)
    connection: Connection;
    // (undocumented)
    cssClass: string;
    // (undocumented)
    edited: boolean;
    // (undocumented)
    gap: number;
    // (undocumented)
    geometry: Geometry;
    // (undocumented)
    getIdPrefix(): string;
    // (undocumented)
    getTypeDescriptor(): string;
    // (undocumented)
    h: number;
    // (undocumented)
    hoverClass: string;
    // (undocumented)
    maxStub: number;
    // (undocumented)
    paintInfo: PaintGeometry;
    // (undocumented)
    segment: number;
    // (undocumented)
    segmentProportionalLengths: Array<number>;
    // (undocumented)
    segmentProportions: Array<[number, number]>;
    // (undocumented)
    segments: Array<Segment>;
    // (undocumented)
    sourceGap: number;
    // (undocumented)
    sourceStub: number;
    // (undocumented)
    strokeWidth: number;
    // (undocumented)
    stub: number | number[];
    // (undocumented)
    targetGap: number;
    // (undocumented)
    targetStub: number;
    // (undocumented)
    totalLength: number;
    // (undocumented)
    typeId: string;
    // (undocumented)
    w: number;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// Warning: (ae-incompatible-release-tags) The symbol "connectorBoundingBoxIntersection" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public (undocumented)
export function connectorBoundingBoxIntersection(connector: ConnectorBase, box: any): Array<PointXY>;

// Warning: (ae-incompatible-release-tags) The symbol "connectorBoxIntersection" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public (undocumented)
export function connectorBoxIntersection(connector: ConnectorBase, x: number, y: number, w: number, h: number): Array<PointXY>;

// @public (undocumented)
export type ConnectorComputeParams = {
    sourcePos: AnchorPlacement;
    targetPos: AnchorPlacement;
    sourceEndpoint: Endpoint;
    targetEndpoint: Endpoint;
    strokeWidth: number;
    sourceInfo: ViewportElement<any>;
    targetInfo: ViewportElement<any>;
};

// @public
export interface ConnectorHandler {
    // Warning: (ae-incompatible-release-tags) The symbol "_compute" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
    // Warning: (ae-incompatible-release-tags) The symbol "_compute" is marked as @public, but its signature references "PaintGeometry" which is marked as @internal
    //
    // (undocumented)
    _compute(connector: ConnectorBase, geometry: PaintGeometry, params: ConnectorComputeParams): void;
    // Warning: (ae-incompatible-release-tags) The symbol "create" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
    //
    // (undocumented)
    create(connection: Connection, connectorType: string, params: any): ConnectorBase;
    // Warning: (ae-incompatible-release-tags) The symbol "exportGeometry" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
    //
    // (undocumented)
    exportGeometry(connector: ConnectorBase): Geometry;
    // Warning: (ae-incompatible-release-tags) The symbol "importGeometry" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
    //
    // (undocumented)
    importGeometry(connector: ConnectorBase, g: Geometry): boolean;
    // Warning: (ae-incompatible-release-tags) The symbol "setAnchorOrientation" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
    //
    // (undocumented)
    setAnchorOrientation(connector: ConnectorBase, idx: number, orientation: number[]): void;
    // Warning: (ae-incompatible-release-tags) The symbol "transformGeometry" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
    //
    // (undocumented)
    transformGeometry(connector: ConnectorBase, g: Geometry, dx: number, dy: number): Geometry;
}

// @public
export const Connectors: {
    register: (connectorType: string, connectorHandler: ConnectorHandler) => void;
    get: (connectorType: string) => ConnectorHandler;
    exportGeometry(connector: ConnectorBase): any;
    importGeometry(connector: ConnectorBase, g: Geometry): any;
    transformGeometry(connector: ConnectorBase, g: Geometry, dx: number, dy: number): any;
    create(connection: Connection<any>, name: string, args: any): ConnectorBase;
    setAnchorOrientation(connector: ConnectorBase, idx: number, orientation: number[]): void;
};

// @public
export interface ConnectParams<E> {
    anchor?: AnchorSpec;
    anchors?: [AnchorSpec, AnchorSpec];
    // (undocumented)
    color?: string;
    connector?: ConnectorSpec;
    cost?: number;
    // (undocumented)
    cssClass?: string;
    // (undocumented)
    data?: any;
    deleteEndpointsOnDetach?: boolean;
    deleteEndpointsOnEmpty?: boolean;
    detachable?: boolean;
    directed?: boolean;
    endpoint?: EndpointSpec;
    endpointHoverStyle?: EndpointStyle;
    endpointHoverStyles?: [EndpointStyle, EndpointStyle];
    endpoints?: [EndpointSpec, EndpointSpec];
    endpointStyle?: EndpointStyle;
    endpointStyles?: [EndpointStyle, EndpointStyle];
    // (undocumented)
    hoverClass?: string;
    hoverPaintStyle?: PaintStyle;
    // (undocumented)
    id?: string;
    label?: string;
    // (undocumented)
    lineWidth?: number;
    // (undocumented)
    outlineColor?: string;
    // (undocumented)
    outlineWidth?: number;
    overlays?: Array<OverlaySpec>;
    paintStyle?: PaintStyle;
    parameters?: Record<string, any>;
    ports?: [string, string];
    reattach?: boolean;
    // (undocumented)
    scope?: string;
    source?: Element | Endpoint;
    target?: Element | Endpoint;
    type?: string;
    uuids?: [UUID, UUID];
}

// @public
export function convertToFullOverlaySpec(spec: string | OverlaySpec): FullOverlaySpec;

// @public (undocumented)
export function createBaseRepresentation(type: string, endpoint: Endpoint, params?: EndpointRepresentationParams): EndpointRepresentation<any>;

// Warning: (ae-incompatible-release-tags) The symbol "createComponentBase" is marked as @public, but its signature references "ComponentOptions" which is marked as @internal
//
// @public (undocumented)
export function createComponentBase(instance: JsPlumbInstance, idPrefix: string, typeDescriptor: string, defaultOverlayKey: string, defaultType: Record<string, any>, defaultLabelLocation: number | [number, number], params?: ComponentOptions): Component;

// Warning: (ae-incompatible-release-tags) The symbol "createConnectorBase" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public
export function createConnectorBase(type: string, connection: Connection, params: ConnectorOptions, defaultStubs: [number, number]): ConnectorBase;

// @public (undocumented)
export function createEndpoint<E>(instance: JsPlumbInstance, params: InternalEndpointOptions<E>): Endpoint;

// @public (undocumented)
export function createFloatingAnchor(instance: JsPlumbInstance, element: Element, elementId: string): LightweightFloatingAnchor;

// @public (undocumented)
export function createOverlayBase(instance: JsPlumbInstance, component: Component, p: OverlayOptions): OverlayBase;

// @public (undocumented)
export function _createPerimeterAnchor(params: Record<string, any>): LightweightPerimeterAnchor;

// @public (undocumented)
export interface CustomOverlay extends OverlayBase {
    // (undocumented)
    create: (c: Component) => any;
}

// @public (undocumented)
export interface CustomOverlayOptions extends OverlayOptions {
    // (undocumented)
    create: (c: Component) => any;
}

// @public (undocumented)
export const DEFAULT_KEY_ALLOW_NESTED_GROUPS = "allowNestedGroups";

// @public (undocumented)
export const DEFAULT_KEY_ANCHOR = "anchor";

// @public (undocumented)
export const DEFAULT_KEY_ANCHORS = "anchors";

// @public (undocumented)
export const DEFAULT_KEY_CONNECTION_OVERLAYS = "connectionOverlays";

// @public (undocumented)
export const DEFAULT_KEY_CONNECTIONS_DETACHABLE = "connectionsDetachable";

// @public (undocumented)
export const DEFAULT_KEY_CONNECTOR = "connector";

// @public (undocumented)
export const DEFAULT_KEY_CONTAINER = "container";

// @public (undocumented)
export const DEFAULT_KEY_ENDPOINT = "endpoint";

// @public (undocumented)
export const DEFAULT_KEY_ENDPOINT_HOVER_STYLE = "endpointHoverStyle";

// @public (undocumented)
export const DEFAULT_KEY_ENDPOINT_HOVER_STYLES = "endpointHoverStyles";

// @public (undocumented)
export const DEFAULT_KEY_ENDPOINT_OVERLAYS = "endpointOverlays";

// @public (undocumented)
export const DEFAULT_KEY_ENDPOINT_STYLE = "endpointStyle";

// @public (undocumented)
export const DEFAULT_KEY_ENDPOINT_STYLES = "endpointStyles";

// @public (undocumented)
export const DEFAULT_KEY_ENDPOINTS = "endpoints";

// @public (undocumented)
export const DEFAULT_KEY_HOVER_CLASS = "hoverClass";

// @public (undocumented)
export const DEFAULT_KEY_HOVER_PAINT_STYLE = "hoverPaintStyle";

// @public (undocumented)
export const DEFAULT_KEY_LIST_STYLE = "listStyle";

// @public (undocumented)
export const DEFAULT_KEY_MAX_CONNECTIONS = "maxConnections";

// @public (undocumented)
export const DEFAULT_KEY_PAINT_STYLE = "paintStyle";

// @public (undocumented)
export const DEFAULT_KEY_REATTACH_CONNECTIONS = "reattachConnections";

// @public (undocumented)
export const DEFAULT_KEY_SCOPE = "scope";

// @public (undocumented)
export const DEFAULT_LABEL_LOCATION_CONNECTION = 0.5;

// @public (undocumented)
export const DEFAULT_LABEL_LOCATION_ENDPOINT: [number, number];

// @public (undocumented)
export const DEFAULT_LENGTH = 20;

// @public (undocumented)
export const DEFAULT_OVERLAY_KEY_ENDPOINTS = "endpointOverlays";

// @public
export const defaultConnectorHandler: {
    exportGeometry(connector: ConnectorBase): Geometry;
    importGeometry(connector: ConnectorBase, g: Geometry): boolean;
};

// @public
export type DeleteConnectionOptions = {
    force?: boolean;
    fireEvent?: boolean;
    originalEvent?: Event;
    endpointToIgnore?: Endpoint;
};

// @public (undocumented)
export interface DiamondOverlay extends ArrowOverlay {
}

// @public (undocumented)
export interface DotEndpoint extends EndpointRepresentation<ComputedDotEndpoint> {
    // (undocumented)
    defaultInnerRadius: number;
    // (undocumented)
    defaultOffset: number;
    // (undocumented)
    radius: number;
}

// @public (undocumented)
export const DotEndpointHandler: EndpointHandler<DotEndpoint, ComputedDotEndpoint>;

// Warning: (ae-incompatible-release-tags) The symbol "dumpSegmentsToConsole" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public (undocumented)
export function dumpSegmentsToConsole(connector: ConnectorBase): void;

// @public (undocumented)
export type ElementSelectionSpecifier<E> = E | Array<E> | '*';

// @public (undocumented)
export interface Endpoint extends Component {
    // (undocumented)
    _anchor: LightweightAnchor;
    // (undocumented)
    connectionCost: number;
    // (undocumented)
    connections: Array<Connection>;
    // (undocumented)
    connectionsDetachable: boolean;
    // (undocumented)
    connectionsDirected: boolean;
    // (undocumented)
    connector: ConnectorSpec;
    // (undocumented)
    connectorClass: string;
    // (undocumented)
    connectorHoverClass: string;
    // (undocumented)
    connectorHoverStyle: PaintStyle;
    // (undocumented)
    connectorOverlays: Array<OverlaySpec>;
    // (undocumented)
    connectorSelector: () => Connection;
    // (undocumented)
    connectorStyle: PaintStyle;
    // (undocumented)
    currentAnchorClass: string;
    // (undocumented)
    deleteOnEmpty: boolean;
    // (undocumented)
    dragAllowedWhenFull: boolean;
    // (undocumented)
    edgeType: string;
    // (undocumented)
    element: any;
    // (undocumented)
    elementId: string;
    // (undocumented)
    enabled: boolean;
    // (undocumented)
    finalEndpoint: Endpoint;
    // (undocumented)
    isSource: boolean;
    // (undocumented)
    isTarget: boolean;
    // (undocumented)
    isTemporarySource: boolean;
    // (undocumented)
    maxConnections: number;
    // (undocumented)
    portId: string;
    // (undocumented)
    proxiedBy: Endpoint;
    // (undocumented)
    reattachConnections: boolean;
    // (undocumented)
    referenceEndpoint: Endpoint;
    // (undocumented)
    representation: EndpointRepresentation<any>;
    // (undocumented)
    scope: string;
    // (undocumented)
    timestamp: string;
    // (undocumented)
    uuid: string;
}

// @public (undocumented)
export type EndpointComputeFunction<T> = (endpoint: EndpointRepresentation<T>, anchorPoint: AnchorPlacement, orientation: Orientation, endpointStyle: any) => T;

// @public (undocumented)
export interface EndpointHandler<EndpointClass, T> {
    // (undocumented)
    compute: EndpointComputeFunction<T>;
    // (undocumented)
    create(endpoint: Endpoint, params?: EndpointRepresentationParams): EndpointClass;
    // (undocumented)
    getParams(endpoint: EndpointClass): Record<string, any>;
    // (undocumented)
    type: string;
}

// @public (undocumented)
export interface EndpointOptions<E = any> {
    anchor?: AnchorSpec;
    anchors?: [AnchorSpec, AnchorSpec];
    connectionCost?: number;
    connectionsDetachable?: boolean;
    connectionsDirected?: boolean;
    connector?: ConnectorSpec;
    connectorClass?: string;
    connectorHoverClass?: string;
    connectorHoverStyle?: PaintStyle;
    connectorOverlays?: Array<OverlaySpec>;
    connectorStyle?: PaintStyle;
    // (undocumented)
    cssClass?: string;
    // (undocumented)
    data?: any;
    deleteOnEmpty?: boolean;
    dragAllowedWhenFull?: boolean;
    edgeType?: string;
    enabled?: boolean;
    endpoint?: EndpointSpec;
    // (undocumented)
    hoverClass?: string;
    hoverPaintStyle?: PaintStyle;
    maxConnections?: number;
    paintStyle?: PaintStyle;
    // (undocumented)
    parameters?: Record<string, any>;
    portId?: string;
    reattachConnections?: boolean;
    // (undocumented)
    scope?: string;
    source?: boolean;
    target?: boolean;
    uuid?: string;
}

// @public
export interface EndpointRepresentation<C> {
    // (undocumented)
    bounds: Extents;
    // (undocumented)
    canvas: any;
    // (undocumented)
    classes: Array<string>;
    // (undocumented)
    computedValue: C;
    // (undocumented)
    endpoint: Endpoint;
    // (undocumented)
    h: number;
    // (undocumented)
    instance: JsPlumbInstance;
    // (undocumented)
    type: string;
    // (undocumented)
    typeDescriptor: typeof TYPE_DESCRIPTOR_ENDPOINT_REPRESENTATION;
    // (undocumented)
    typeId: string;
    // (undocumented)
    w: number;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @public
export const Endpoints: {
    applyType(endpoint: Endpoint, t: any, typeMap: any): void;
    destroy(endpoint: Endpoint): void;
    setVisible(endpoint: Endpoint, v: boolean, doNotChangeConnections?: boolean, doNotNotifyOtherEndpoint?: boolean): void;
    addClass(endpoint: Endpoint, clazz: string, cascade?: boolean): void;
    removeClass(endpoint: Endpoint, clazz: string, cascade?: boolean): void;
    _setPreparedAnchor(endpoint: Endpoint, anchor: LightweightAnchor): Endpoint;
    _updateAnchorClass(endpoint: Endpoint): void;
    _anchorLocationChanged(endpoint: Endpoint, currentAnchor: LightweightAnchor): void;
    setAnchor(endpoint: Endpoint, anchorParams: AnchorSpec | Array<AnchorSpec>): Endpoint;
    _addConnection(endpoint: Endpoint, conn: Connection): void;
    deleteEveryConnection(endpoint: Endpoint, params?: DeleteConnectionOptions): void;
    detachFrom(endpoint: Endpoint, otherEndpoint: Endpoint): Endpoint;
    detachFromConnection(endpoint: Endpoint, connection: Connection, idx?: number, _transientDetach?: boolean): void;
    isFull(endpoint: Endpoint): boolean;
    _isFloating(endpoint: Endpoint): boolean;
    areConnected(endpoint: Endpoint, otherEndpoint: Endpoint): boolean;
    _isEndpoint(component: any): component is Endpoint;
    _setEndpoint<C>(endpoint: Endpoint, ep: EndpointSpec | EndpointRepresentation<C>): void;
    _setPreparedEndpoint<C_1>(endpoint: Endpoint, ep: EndpointRepresentation<C_1>): void;
    _compute<T, ElementType>(ep: EndpointRepresentation<T>, anchorPoint: AnchorPlacement, orientation: Orientation, endpointStyle: any): void;
    _registerHandler<E, T_1>(eph: EndpointHandler<E, T_1>): void;
};

// @public
export class EndpointSelection extends SelectionBase<Endpoint> {
    deleteAll(): EndpointSelection;
    deleteEveryConnection(): EndpointSelection;
    setAnchor(a: AnchorSpec): EndpointSelection;
    setEnabled(e: boolean): EndpointSelection;
}

// @public
export interface EndpointTypeDescriptor extends TypeDescriptor {
    connectionsDetachable?: boolean;
    maxConnections?: number;
    reattachConnections?: boolean;
}

// @public (undocumented)
export const ERROR_SOURCE_DOES_NOT_EXIST = "Cannot establish connection: source does not exist";

// @public (undocumented)
export const ERROR_SOURCE_ENDPOINT_FULL = "Cannot establish connection: source endpoint is full";

// @public (undocumented)
export const ERROR_TARGET_DOES_NOT_EXIST = "Cannot establish connection: target does not exist";

// @public (undocumented)
export const ERROR_TARGET_ENDPOINT_FULL = "Cannot establish connection: target endpoint is full";

// @public (undocumented)
export const EVENT_ANCHOR_CHANGED = "anchor:changed";

// @public (undocumented)
export const EVENT_CONNECTION = "connection";

// @public (undocumented)
export const EVENT_CONNECTION_DETACHED = "connection:detach";

// @public (undocumented)
export const EVENT_CONNECTION_MOVED = "connection:move";

// @public (undocumented)
export const EVENT_CONTAINER_CHANGE = "container:change";

// @public (undocumented)
export const EVENT_ENDPOINT_REPLACED = "endpoint:replaced";

// @public (undocumented)
export const EVENT_GROUP_ADDED = "group:added";

// @public (undocumented)
export const EVENT_GROUP_COLLAPSE = "group:collapse";

// @public (undocumented)
export const EVENT_GROUP_EXPAND = "group:expand";

// @public (undocumented)
export const EVENT_GROUP_MEMBER_ADDED = "group:member:added";

// @public (undocumented)
export const EVENT_GROUP_MEMBER_REMOVED = "group:member:removed";

// @public (undocumented)
export const EVENT_GROUP_REMOVED = "group:removed";

// @public (undocumented)
export const EVENT_INTERNAL_CONNECTION = "internal.connection";

// @public (undocumented)
export const EVENT_INTERNAL_CONNECTION_DETACHED = "internal.connection:detached";

// @public (undocumented)
export const EVENT_INTERNAL_ENDPOINT_UNREGISTERED = "internal.endpoint:unregistered";

// @public (undocumented)
export const EVENT_MANAGE_ELEMENT = "element:manage";

// @public (undocumented)
export const EVENT_MAX_CONNECTIONS = "maxConnections";

// @public (undocumented)
export const EVENT_NESTED_GROUP_ADDED = "group:nested:added";

// @public (undocumented)
export const EVENT_NESTED_GROUP_REMOVED = "group:nested:removed";

// @public (undocumented)
export const EVENT_UNMANAGE_ELEMENT = "element:unmanage";

// @public (undocumented)
export const EVENT_ZOOM = "zoom";

// Warning: (ae-forgotten-export) The symbol "FaceValues" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type Face = keyof typeof FaceValues;

// Warning: (ae-incompatible-release-tags) The symbol "_findSegmentForLocation" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public
export function _findSegmentForLocation(connector: ConnectorBase, location: number, absolute?: boolean): {
    segment: Segment;
    proportion: number;
    index: number;
};

// Warning: (ae-forgotten-export) The symbol "SegmentForPoint" needs to be exported by the entry point index.d.ts
// Warning: (ae-incompatible-release-tags) The symbol "findSegmentForPoint" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public
export function findSegmentForPoint(connector: ConnectorBase, x: number, y: number): SegmentForPoint;

// @public (undocumented)
export const FIXED = "fixed";

// Warning: (ae-internal-missing-underscore) The name "getDefaultFace" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function getDefaultFace(a: LightweightContinuousAnchor): Face;

// Warning: (ae-incompatible-release-tags) The symbol "gradientAtComponentPoint" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public (undocumented)
export function gradientAtComponentPoint(connector: ConnectorBase, location: number, absolute?: boolean): number;

// @public (undocumented)
export interface GroupCollapsedParams<E> {
    // (undocumented)
    group: UIGroup<E>;
}

// @public (undocumented)
export interface GroupExpandedParams<E> {
    // (undocumented)
    group: UIGroup<E>;
}

// @public (undocumented)
export class GroupManager<E> {
    constructor(instance: JsPlumbInstance);
    // (undocumented)
    addGroup(params: AddGroupOptions<E>): UIGroup<E>;
    // (undocumented)
    addToGroup(group: string | UIGroup<E>, doNotFireEvent: boolean, ...el: Array<E>): void;
    cascadeCollapse(collapsedGroup: UIGroup<E>, targetGroup: UIGroup<E>, collapsedIds: Set<string>): void;
    // (undocumented)
    collapseGroup(group: string | UIGroup<E>): void;
    // (undocumented)
    _connectionSourceMap: Record<string, UIGroup<E>>;
    // (undocumented)
    _connectionTargetMap: Record<string, UIGroup<E>>;
    // (undocumented)
    expandGroup(group: string | UIGroup<E>, doNotFireEvent?: boolean): void;
    // (undocumented)
    forEach(f: (g: UIGroup<E>) => any): void;
    // (undocumented)
    getAncestors(group: UIGroup<E>): Array<UIGroup<E>>;
    // (undocumented)
    getAnchor(group: UIGroup<E>, conn: Connection, endpointIndex: number): AnchorSpec;
    // (undocumented)
    getDescendants(group: UIGroup<E>): Array<UIGroup<E>>;
    // (undocumented)
    getEndpoint(group: UIGroup<E>, conn: Connection, endpointIndex: number): EndpointSpec;
    // (undocumented)
    getGroup(groupId: string | UIGroup<E>): UIGroup<E>;
    // (undocumented)
    getGroupFor(el: E): UIGroup<E>;
    // (undocumented)
    getGroups(): Array<UIGroup<E>>;
    // (undocumented)
    groupMap: Record<string, UIGroup<E>>;
    // (undocumented)
    instance: JsPlumbInstance;
    isAncestor(group: UIGroup<E>, possibleAncestor: UIGroup<E>): boolean;
    // (undocumented)
    isDescendant(possibleDescendant: UIGroup<E>, ancestor: UIGroup<E>): boolean;
    // (undocumented)
    isOverrideDrop(group: UIGroup<E>, el: any, targetGroup: UIGroup<E>): boolean;
    // (undocumented)
    orphan(el: E, doNotTransferToAncestor: boolean): {
        id: string;
        pos: PointXY;
    };
    // (undocumented)
    removeAllGroups(deleteMembers?: boolean, manipulateView?: boolean, doNotFireEvent?: boolean): void;
    // (undocumented)
    removeFromGroup(group: string | UIGroup<E>, doNotFireEvent: boolean, ...el: Array<E>): void;
    // (undocumented)
    removeGroup(group: string | UIGroup<E>, deleteMembers?: boolean, manipulateView?: boolean, doNotFireEvent?: boolean): Record<string, PointXY>;
    // (undocumented)
    repaintGroup(group: string | UIGroup<E>): void;
    // (undocumented)
    reset(): void;
    // (undocumented)
    toggleGroup(group: string | UIGroup<E>): void;
    // (undocumented)
    _updateConnectionsForGroup(group: UIGroup<E>): void;
}

// @public (undocumented)
export interface GroupOptions {
    // (undocumented)
    anchor?: AnchorSpec;
    // (undocumented)
    constrain?: boolean;
    // (undocumented)
    dropOverride?: boolean;
    // (undocumented)
    droppable?: boolean;
    // (undocumented)
    enabled?: boolean;
    // (undocumented)
    endpoint?: EndpointSpec;
    // (undocumented)
    ghost?: boolean;
    // (undocumented)
    id?: string;
    // (undocumented)
    orphan?: boolean;
    // (undocumented)
    proxied?: boolean;
    // (undocumented)
    prune?: boolean;
    // (undocumented)
    revert?: boolean;
}

// Warning: (ae-internal-missing-underscore) The name "ID_PREFIX_CONNECTION" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export const ID_PREFIX_CONNECTION = "_jsPlumb_c";

// @public (undocumented)
export const ID_PREFIX_ENDPOINT = "_jsplumb_e";

// @public (undocumented)
export const INTERCEPT_BEFORE_DETACH = "beforeDetach";

// @public (undocumented)
export const INTERCEPT_BEFORE_DRAG = "beforeDrag";

// @public (undocumented)
export const INTERCEPT_BEFORE_DROP = "beforeDrop";

// @public (undocumented)
export const INTERCEPT_BEFORE_START_DETACH = "beforeStartDetach";

// Warning: (ae-internal-missing-underscore) The name "InternalConnectParams" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface InternalConnectParams<E> extends ConnectParams<E> {
    // (undocumented)
    id?: string;
    // (undocumented)
    newConnection?: (p: any) => Connection;
    // (undocumented)
    scope?: string;
    // (undocumented)
    sourceEndpoint?: Endpoint;
    // (undocumented)
    targetEndpoint?: Endpoint;
    // (undocumented)
    type?: string;
}

// @public (undocumented)
export interface InternalEndpointOptions<E> extends EndpointOptions<E> {
    // (undocumented)
    connections?: Array<Connection>;
    // (undocumented)
    element?: E;
    // (undocumented)
    elementId?: string;
    // (undocumented)
    existingEndpoint?: EndpointRepresentation<E>;
    // (undocumented)
    id?: string;
    // (undocumented)
    isTemporarySource?: boolean;
    // (undocumented)
    preparedAnchor?: LightweightAnchor;
    // (undocumented)
    _transient?: boolean;
    // (undocumented)
    type?: string;
}

// @public (undocumented)
export const IS_DETACH_ALLOWED = "isDetachAllowed";

// @public (undocumented)
export function isArrowOverlay(o: OverlayBase): o is ArrowOverlay;

// @public (undocumented)
export function isContinuous(a: LightweightAnchor): a is LightweightContinuousAnchor;

// @public (undocumented)
export function isCustomOverlay(o: OverlayBase): o is CustomOverlay;

// @public (undocumented)
export function isDiamondOverlay(o: OverlayBase): o is DiamondOverlay;

// @public (undocumented)
export function isDynamic(a: LightweightAnchor): boolean;

// Warning: (ae-internal-missing-underscore) The name "isEdgeSupported" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function isEdgeSupported(a: LightweightContinuousAnchor, edge: Face): boolean;

// @public (undocumented)
export function isEndpointRepresentation(ep: any): ep is EndpointRepresentation<any>;

// @public (undocumented)
export function isFloating(a: LightweightAnchor): a is LightweightFloatingAnchor;

// @public
export function isFullOverlaySpec(o: OverlaySpec): o is FullOverlaySpec;

// @public (undocumented)
export function isLabelOverlay(o: OverlayBase): o is LabelOverlay;

// @public (undocumented)
export function isPlainArrowOverlay(o: OverlayBase): o is PlainArrowOverlay;

// Warning: (ae-internal-missing-underscore) The name "isValidAnchorsSpec" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function isValidAnchorsSpec(anchors: [AnchorSpec, AnchorSpec]): boolean;

// @public (undocumented)
export interface JsPlumbDefaults<E> {
    // (undocumented)
    [DEFAULT_KEY_ALLOW_NESTED_GROUPS]?: boolean;
    // (undocumented)
    [DEFAULT_KEY_ANCHOR]?: AnchorSpec;
    // (undocumented)
    [DEFAULT_KEY_ANCHORS]?: [AnchorSpec, AnchorSpec];
    // (undocumented)
    [DEFAULT_KEY_CONNECTION_OVERLAYS]?: Array<OverlaySpec>;
    // (undocumented)
    [DEFAULT_KEY_CONNECTIONS_DETACHABLE]?: boolean;
    // (undocumented)
    [DEFAULT_KEY_CONNECTOR]?: ConnectorSpec;
    // (undocumented)
    [DEFAULT_KEY_CONTAINER]?: E;
    // (undocumented)
    [DEFAULT_KEY_ENDPOINT]?: EndpointSpec;
    // (undocumented)
    [DEFAULT_KEY_ENDPOINT_HOVER_STYLE]?: EndpointStyle;
    // (undocumented)
    [DEFAULT_KEY_ENDPOINT_HOVER_STYLES]?: [EndpointStyle, EndpointStyle];
    // (undocumented)
    [DEFAULT_KEY_ENDPOINT_OVERLAYS]?: Array<OverlaySpec>;
    // (undocumented)
    [DEFAULT_KEY_ENDPOINTS]?: [EndpointSpec, EndpointSpec];
    // (undocumented)
    [DEFAULT_KEY_ENDPOINT_STYLE]?: EndpointStyle;
    // (undocumented)
    [DEFAULT_KEY_ENDPOINT_STYLES]?: [EndpointStyle, EndpointStyle];
    // (undocumented)
    [DEFAULT_KEY_HOVER_CLASS]?: string;
    // (undocumented)
    [DEFAULT_KEY_HOVER_PAINT_STYLE]?: PaintStyle;
    // (undocumented)
    [DEFAULT_KEY_LIST_STYLE]?: ListSpec;
    // (undocumented)
    [DEFAULT_KEY_MAX_CONNECTIONS]?: number;
    // (undocumented)
    [DEFAULT_KEY_PAINT_STYLE]?: PaintStyle;
    // (undocumented)
    [DEFAULT_KEY_REATTACH_CONNECTIONS]?: boolean;
    // (undocumented)
    [DEFAULT_KEY_SCOPE]?: string;
}

// @public (undocumented)
export interface jsPlumbElement<E> {
    // (undocumented)
    _isJsPlumbGroup: boolean;
    // (undocumented)
    _jsPlumbGroup: UIGroup<E>;
    // (undocumented)
    _jsPlumbParentGroup: UIGroup<E>;
    // (undocumented)
    _jsPlumbProxies: Array<[Connection, number]>;
    // (undocumented)
    parentNode: jsPlumbElement<E>;
}

// @public (undocumented)
export abstract class JsPlumbInstance<T extends {
    E: unknown;
} = any> extends EventGenerator {
    constructor(_instanceIndex: number, defaults?: JsPlumbDefaults<T["E"]>);
    // (undocumented)
    abstract addClass(el: T["E"] | ArrayLike<T["E"]>, clazz: string): void;
    // @internal (undocumented)
    abstract addConnectorClass(connector: ConnectorBase, clazz: string): void;
    addEndpoint(el: T["E"], params?: EndpointOptions<T["E"]>, referenceParams?: EndpointOptions<T["E"]>): Endpoint;
    // (undocumented)
    abstract addEndpointClass(ep: Endpoint, c: string): void;
    addEndpoints(el: T["E"], endpoints: Array<EndpointOptions<T["E"]>>, referenceParams?: EndpointOptions<T["E"]>): Array<Endpoint>;
    addGroup(params: AddGroupOptions<T["E"]>): UIGroup<T["E"]>;
    addOverlay(component: Component, overlay: OverlaySpec, doNotRevalidate?: boolean): void;
    // (undocumented)
    abstract addOverlayClass(o: OverlayBase, clazz: string): void;
    addSourceSelector(selector: string, params?: BehaviouralTypeDescriptor, exclude?: boolean): ConnectionDragSelector;
    addTargetSelector(selector: string, params?: BehaviouralTypeDescriptor, exclude?: boolean): ConnectionDragSelector;
    addToGroup(group: string | UIGroup<T["E"]>, ...el: Array<T["E"]>): void;
    // (undocumented)
    allowNestedGroups: boolean;
    // (undocumented)
    abstract _appendElement(el: T["E"], parent: T["E"]): void;
    // (undocumented)
    abstract _appendElementToContainer(e: T["E"]): void;
    // (undocumented)
    abstract _appendElementToGroup(group: UIGroup, e: T["E"]): void;
    // Warning: (ae-incompatible-release-tags) The symbol "applyConnectorType" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
    //
    // (undocumented)
    abstract applyConnectorType(connector: ConnectorBase, t: TypeDescriptor): void;
    // (undocumented)
    abstract applyEndpointType(ep: Endpoint, t: TypeDescriptor): void;
    // @internal
    _applyRotations(point: [number, number, number, number], rotations: Rotations): RotatedPointXY;
    // @internal
    _applyRotationsXY(point: PointXY, rotations: Rotations): PointXY;
    // @internal (undocumented)
    areDefaultAnchorsSet(): boolean;
    batch(fn: Function, doNotRepaintAfterwards?: boolean): void;
    // (undocumented)
    checkCondition<RetVal>(conditionName: string, args?: any): RetVal;
    collapseGroup(group: string | UIGroup<T["E"]>): void;
    connect(params: ConnectParams<T["E"]>, referenceParams?: ConnectParams<T["E"]>): Connection;
    // (undocumented)
    connectedClass: string;
    // (undocumented)
    readonly connections: Array<Connection>;
    // (undocumented)
    connectorClass: string;
    // (undocumented)
    connectorOutlineClass: string;
    // (undocumented)
    protected _createSourceDefinition(params?: BehaviouralTypeDescriptor, referenceParams?: BehaviouralTypeDescriptor): SourceDefinition;
    // (undocumented)
    currentlyDragging: boolean;
    // (undocumented)
    get currentZoom(): number;
    // (undocumented)
    defaults: JsPlumbDefaults<T["E"]>;
    // (undocumented)
    get defaultScope(): string;
    deleteConnection(connection: Connection, params?: DeleteConnectionOptions): boolean;
    deleteConnectionsForElement(el: T["E"], params?: DeleteConnectionOptions): JsPlumbInstance;
    deleteEndpoint(object: string | Endpoint): JsPlumbInstance;
    // (undocumented)
    deleteEveryConnection(params?: DeleteConnectionOptions): number;
    // @internal
    _deriveEndpointAndAnchorSpec(type: string, dontPrependDefault?: boolean): {
        endpoints: [EndpointSpec, EndpointSpec];
        anchors: [AnchorSpec, AnchorSpec];
    };
    destroy(): void;
    // @internal (undocumented)
    abstract destroyConnector(connection: Connection, force?: boolean): void;
    // (undocumented)
    abstract destroyEndpoint(ep: Endpoint): void;
    // (undocumented)
    abstract destroyOverlay(o: OverlayBase): void;
    // (undocumented)
    abstract drawOverlay(overlay: OverlayBase, component: Component, paintStyle: PaintStyle, absolutePosition?: PointXY): any;
    each(spec: T["E"] | Array<T["E"]>, fn: (e: T["E"]) => any): JsPlumbInstance;
    // (undocumented)
    endpointAnchorClassPrefix: string;
    // (undocumented)
    endpointClass: string;
    // (undocumented)
    endpointConnectedClass: string;
    // (undocumented)
    endpointDropAllowedClass: string;
    // (undocumented)
    endpointDropForbiddenClass: string;
    // (undocumented)
    endpointFloatingClass: string;
    // (undocumented)
    endpointFullClass: string;
    // (undocumented)
    endpointsByElement: Record<string, Array<Endpoint>>;
    expandGroup(group: string | UIGroup<T["E"]>): void;
    // @internal
    _finaliseConnection(jpc: Connection, params?: any, originalEvent?: Event): void;
    // (undocumented)
    fireMoveEvent(params?: ConnectionMovedParams, evt?: Event): void;
    // @internal
    abstract _getAssociatedElements(el: T["E"]): Array<T["E"]>;
    // (undocumented)
    abstract getAttribute(el: T["E"], name: string): string;
    // (undocumented)
    abstract getClass(el: T["E"]): string;
    // (undocumented)
    getConnections(options?: SelectOptions<T["E"]>, flat?: boolean): Record<string, Connection> | Array<Connection>;
    getConnectionType(id: string): ConnectionTypeDescriptor;
    // Warning: (ae-incompatible-release-tags) The symbol "getConnectorClass" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
    //
    // (undocumented)
    abstract getConnectorClass(connector: ConnectorBase): string;
    // (undocumented)
    getContainer(): any;
    getEndpoint(uuid: string): Endpoint;
    // (undocumented)
    abstract getEndpointClass(ep: Endpoint): string;
    getEndpoints(el: T["E"]): Array<Endpoint>;
    getEndpointType(id: string): EndpointTypeDescriptor;
    getGroup(groupId: string): UIGroup<T["E"]>;
    // (undocumented)
    abstract getGroupContentArea(group: UIGroup): T["E"];
    getGroupFor(el: T["E"]): UIGroup<T["E"]>;
    // (undocumented)
    getId(element: T["E"], uuid?: string): string;
    // @internal
    getManagedData(elementId: string, dataIdentifier: string, key: string): any;
    getManagedElement(id: string): T["E"];
    getManagedElements(): Record<string, ManagedElement<T["E"]>>;
    // (undocumented)
    abstract getOffset(el: T["E"]): PointXY;
    // (undocumented)
    abstract getOffsetRelativeToRoot(el: T["E"] | string): PointXY;
    // @internal (undocumented)
    getPathData(connector: ConnectorBase): any;
    // @internal
    _getRotation(elementId: string): number;
    // @internal
    _getRotations(elementId: string): Rotations;
    // (undocumented)
    abstract getSelector(ctx: string | T["E"], spec?: string): ArrayLike<T["E"]>;
    // (undocumented)
    abstract getSize(el: T["E"]): Size;
    // (undocumented)
    abstract getStyle(el: T["E"], prop: string): any;
    // (undocumented)
    getSuspendedAt(): string;
    getType(id: string, typeDescriptor: string): TypeDescriptor;
    // (undocumented)
    readonly groupManager: GroupManager<T["E"]>;
    // (undocumented)
    abstract hasClass(el: T["E"], clazz: string): boolean;
    // (undocumented)
    hide(el: T["E"], changeEndpoints?: boolean): JsPlumbInstance;
    // (undocumented)
    hoverSuspended: boolean;
    // (undocumented)
    _idstamp(): string;
    importDefaults(d: JsPlumbDefaults<T["E"]>): JsPlumbInstance;
    // (undocumented)
    readonly _instanceIndex: number;
    // @internal
    _internal_newEndpoint(params: InternalEndpointOptions<T["E"]>): Endpoint;
    // (undocumented)
    isConnectionBeingDragged: boolean;
    isHoverSuspended(): boolean;
    manage(element: T["E"], internalId?: string, _recalc?: boolean): ManagedElement<T["E"]>;
    manageAll(elements: ArrayLike<T["E"]> | string, recalc?: boolean): void;
    // (undocumented)
    protected _managedElements: Record<string, ManagedElement<T["E"]>>;
    // @internal
    _maybePruneEndpoint(endpoint: Endpoint): boolean;
    // @internal
    _newConnection(params: ConnectionOptions<T["E"]>): Connection;
    // (undocumented)
    abstract off(el: Document | T["E"] | ArrayLike<T["E"]>, event: string, callback: Function): void;
    // (undocumented)
    abstract on(el: Document | T["E"] | ArrayLike<T["E"]>, event: string, callbackOrSelector: Function | string, callback?: Function): void;
    // (undocumented)
    overlayClass: string;
    // @internal (undocumented)
    _paintConnection(connection: Connection, params?: {
        timestamp?: string;
    }): void;
    // @internal (undocumented)
    abstract paintConnector(connector: ConnectorBase, paintStyle: PaintStyle, extents?: Extents): void;
    // @internal (undocumented)
    _paintEndpoint(endpoint: Endpoint, params: {
        timestamp?: string;
        offset?: ViewportElement<T["E"]>;
        recalc?: boolean;
        elementWithPrecedence?: string;
        connectorPaintStyle?: PaintStyle;
        anchorLoc?: AnchorPlacement;
    }): void;
    // @internal (undocumented)
    abstract _paintOverlay(o: OverlayBase, params: any, extents: any): void;
    // @internal (undocumented)
    proxyConnection(connection: Connection, index: number, proxyEl: T["E"], endpointGenerator: (c: Connection, idx: number) => EndpointSpec, anchorGenerator: (c: Connection, idx: number) => AnchorSpec): void;
    // (undocumented)
    abstract reattachOverlay(o: OverlayBase, c: Component): void;
    // @internal (undocumented)
    _refreshEndpoint(endpoint: Endpoint): void;
    registerConnectionType(id: string, type: ConnectionTypeDescriptor): void;
    registerConnectionTypes(types: Record<string, ConnectionTypeDescriptor>): void;
    registerEndpointType(id: string, type: EndpointTypeDescriptor): void;
    registerEndpointTypes(types: Record<string, EndpointTypeDescriptor>): void;
    removeAllEndpoints(el: T["E"], recurse?: boolean): JsPlumbInstance;
    removeAllGroups(deleteMembers?: boolean, _manipulateView?: boolean): void;
    // (undocumented)
    abstract removeAttribute(el: T["E"], attName: string): void;
    // (undocumented)
    abstract removeClass(el: T["E"] | ArrayLike<T["E"]>, clazz: string): void;
    // Warning: (ae-incompatible-release-tags) The symbol "removeConnectorClass" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
    //
    // (undocumented)
    abstract removeConnectorClass(connector: ConnectorBase, clazz: string): void;
    // (undocumented)
    abstract _removeElement(el: T["E"]): void;
    // (undocumented)
    abstract removeEndpointClass(ep: Endpoint, c: string): void;
    removeFromGroup(group: string | UIGroup<T["E"]>, el: T["E"], _doNotFireEvent?: boolean): void;
    removeGroup(group: string | UIGroup<T["E"]>, deleteMembers?: boolean, _manipulateView?: boolean, _doNotFireEvent?: boolean): Record<string, PointXY>;
    removeOverlay(component: Component, overlayId: string): void;
    // (undocumented)
    abstract removeOverlayClass(o: OverlayBase, clazz: string): void;
    removeSourceSelector(selector: ConnectionDragSelector): void;
    removeTargetSelector(selector: ConnectionDragSelector): void;
    // (undocumented)
    abstract renderEndpoint(ep: Endpoint, paintStyle: PaintStyle): void;
    repaint(el: T["E"], timestamp?: string, offsetsWereJustCalculated?: boolean): RedrawResult;
    repaintEverything(): JsPlumbInstance;
    reset(): void;
    restoreDefaults(): JsPlumbInstance;
    revalidate(el: T["E"], timestamp?: string): RedrawResult;
    rotate(element: T["E"], rotation: number, _doNotRepaint?: boolean): RedrawResult;
    // (undocumented)
    readonly router: Router<T, any>;
    // (undocumented)
    select(params?: SelectOptions<T["E"]>): ConnectionSelection;
    // (undocumented)
    selectEndpoints(params?: SelectEndpointOptions<T["E"]>): EndpointSelection;
    // (undocumented)
    abstract setAttribute(el: T["E"], name: string, value: string): void;
    // (undocumented)
    abstract setAttributes(el: T["E"], atts: Record<string, string>): void;
    setColor(conn: Connection, color: string): void;
    setConnectionType(connection: Connection, type: string, params?: any): void;
    // @internal (undocumented)
    abstract setConnectorHover(connector: ConnectorBase, h: boolean, sourceEndpoint?: Endpoint): void;
    // Warning: (ae-incompatible-release-tags) The symbol "setConnectorVisible" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
    //
    // (undocumented)
    abstract setConnectorVisible(connector: ConnectorBase, v: boolean): void;
    // (undocumented)
    setContainer(c: T["E"]): void;
    setElementPosition(el: T["E"], x: number, y: number): RedrawResult;
    // (undocumented)
    abstract setEndpointHover(endpoint: Endpoint, h: boolean, endpointIndex: number, doNotCascade?: boolean): void;
    setEndpointUuid(endpoint: Endpoint, uuid: string): void;
    // (undocumented)
    abstract setEndpointVisible(ep: Endpoint, v: boolean): void;
    // (undocumented)
    abstract setGroupVisible(group: UIGroup, state: boolean): void;
    // (undocumented)
    abstract setHover(component: Component, hover: boolean): void;
    setLineStyle(conn: Connection, style: {
        lineWidth?: number;
        outlineWidth?: number;
        color?: string;
        outlineColor?: string;
    }): void;
    setLineWidth(conn: Connection, width: number): void;
    // @internal
    setManagedData(elementId: string, dataIdentifier: string, key: string, data: any): void;
    setOutlineColor(conn: Connection, color: string): void;
    setOutlineWidth(conn: Connection, width: number): void;
    // (undocumented)
    abstract setOverlayHover(o: OverlayBase, hover: boolean): void;
    // (undocumented)
    abstract setOverlayVisible(o: OverlayBase, visible: boolean): void;
    // (undocumented)
    abstract setPosition(el: T["E"], p: PointXY): void;
    setSource(connection: Connection, el: T["E"] | Endpoint): void;
    setSuspendDrawing(val?: boolean, repaintAfterwards?: boolean): boolean;
    setTarget(connection: Connection, el: T["E"] | Endpoint): void;
    // (undocumented)
    setZoom(z: number, repaintEverything?: boolean): boolean;
    // (undocumented)
    show(el: T["E"], changeEndpoints?: boolean): JsPlumbInstance;
    // @internal (undocumented)
    sourceOrTargetChanged(originalId: string, newId: string, connection: Connection, newElement: T["E"], index: number): void;
    // (undocumented)
    sourceSelectors: Array<ConnectionDragSelector>;
    // (undocumented)
    _suspendDrawing: boolean;
    // (undocumented)
    _suspendedAt: string;
    // (undocumented)
    targetSelectors: Array<ConnectionDragSelector>;
    // (undocumented)
    abstract toggleClass(el: T["E"] | ArrayLike<T["E"]>, clazz: string): void;
    toggleGroup(group: string | UIGroup<T["E"]>): void;
    toggleVisible(el: T["E"], changeEndpoints?: boolean): void;
    // (undocumented)
    abstract trigger(el: Document | T["E"], event: string, originalEvent?: Event, payload?: any, detail?: number): void;
    unmanage(el: T["E"], removeElement?: boolean): void;
    // @internal (undocumented)
    unproxyConnection(connection: Connection, index: number): void;
    // (undocumented)
    abstract updateLabel(o: LabelOverlay): void;
    // Warning: (ae-incompatible-release-tags) The symbol "updateOffset" is marked as @public, but its signature references "UpdateOffsetOptions" which is marked as @internal
    // Warning: (ae-incompatible-release-tags) The symbol "updateOffset" is marked as @public, but its signature references "ViewportElement" which is marked as @internal
    updateOffset(params?: UpdateOffsetOptions): ViewportElement<T["E"]>;
    // (undocumented)
    readonly viewport: Viewport<T>;
}

// @public (undocumented)
export const KEY_CONNECTION_OVERLAYS = "connectionOverlays";

// @public (undocumented)
export interface LabelOverlay extends OverlayBase {
    // (undocumented)
    cachedDimensions: Size;
    // (undocumented)
    label: string | Function;
    // (undocumented)
    labelText: string;
}

// @public (undocumented)
export const Labels: {
    setLabel(overlay: LabelOverlay, l: string | Function): void;
    getLabel(overlay: LabelOverlay): string;
};

// @public (undocumented)
export const LEFT = FaceValues.left;

// @public (undocumented)
export interface LightweightAnchor {
    // Warning: (ae-incompatible-release-tags) The symbol "computedPosition" is marked as @public, but its signature references "ComputedPosition" which is marked as @internal
    //
    // (undocumented)
    computedPosition?: ComputedPosition;
    // (undocumented)
    cssClass: string;
    // (undocumented)
    currentLocation: number;
    // (undocumented)
    id: string;
    // (undocumented)
    isContinuous: boolean;
    // (undocumented)
    isDynamic: boolean;
    // (undocumented)
    isFloating: boolean;
    // Warning: (ae-incompatible-release-tags) The symbol "locations" is marked as @public, but its signature references "AnchorRecord" which is marked as @internal
    //
    // (undocumented)
    locations: Array<AnchorRecord>;
    // (undocumented)
    locked: boolean;
    // (undocumented)
    timestamp: string;
    // (undocumented)
    type: string;
}

// @public (undocumented)
export interface LightweightContinuousAnchor extends LightweightAnchor {
    // (undocumented)
    clockwise: boolean;
    // (undocumented)
    currentFace: Face;
    // (undocumented)
    faces: Array<Face>;
    // (undocumented)
    isContinuous: true;
    // (undocumented)
    isDynamic: false;
    // (undocumented)
    lockedAxis: Axis;
    // (undocumented)
    lockedFace: Face;
}

// @public (undocumented)
export class LightweightFloatingAnchor implements LightweightAnchor {
    constructor(instance: JsPlumbInstance, element: Element, elementId: string);
    // (undocumented)
    cssClass: string;
    // (undocumented)
    currentLocation: number;
    // (undocumented)
    element: Element;
    // (undocumented)
    id: string;
    // (undocumented)
    instance: JsPlumbInstance;
    // (undocumented)
    isContinuous: false;
    // (undocumented)
    isDynamic: false;
    // (undocumented)
    isFloating: boolean;
    // Warning: (ae-incompatible-release-tags) The symbol "locations" is marked as @public, but its signature references "AnchorRecord" which is marked as @internal
    //
    // (undocumented)
    locations: Array<AnchorRecord>;
    // (undocumented)
    locked: boolean;
    // (undocumented)
    orientation: Orientation;
    out(): void;
    over(endpoint: Endpoint): void;
    // (undocumented)
    size: Size;
    // (undocumented)
    timestamp: string;
    // (undocumented)
    type: string;
}

// @public (undocumented)
export interface LightweightPerimeterAnchor extends LightweightAnchor {
    // (undocumented)
    shape: PerimeterAnchorShapes;
}

// @public (undocumented)
export class LightweightRouter<T extends {
    E: unknown;
}> implements Router<T, LightweightAnchor> {
    constructor(instance: JsPlumbInstance);
    // Warning: (ae-forgotten-export) The symbol "AnchorLists" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    anchorLists: Map<string, AnchorLists>;
    // (undocumented)
    anchorLocations: Map<string, AnchorPlacement>;
    // @internal
    anchorsEqual(a1: LightweightAnchor, a2: LightweightAnchor): boolean;
    // Warning: (ae-incompatible-release-tags) The symbol "computeAnchorLocation" is marked as @public, but its signature references "AnchorComputeParams" which is marked as @internal
    //
    // (undocumented)
    computeAnchorLocation(anchor: LightweightAnchor, params: AnchorComputeParams): AnchorPlacement;
    // (undocumented)
    computePath(connection: Connection<any>, timestamp: string): void;
    // (undocumented)
    getAnchorOrientation(anchor: LightweightAnchor): Orientation;
    // Warning: (ae-incompatible-release-tags) The symbol "getEndpointLocation" is marked as @public, but its signature references "AnchorComputeParams" which is marked as @internal
    //
    // (undocumented)
    getEndpointLocation(endpoint: Endpoint, params: AnchorComputeParams): AnchorPlacement;
    // (undocumented)
    getEndpointOrientation(ep: Endpoint): Orientation;
    // (undocumented)
    instance: JsPlumbInstance;
    // (undocumented)
    isDynamicAnchor(ep: Endpoint): boolean;
    // (undocumented)
    isFloating(ep: Endpoint): boolean;
    // @internal (undocumented)
    lock(a: LightweightAnchor): void;
    // @internal (undocumented)
    lockCurrentAxis(a: LightweightContinuousAnchor): void;
    // (undocumented)
    prepareAnchor(params: AnchorSpec | Array<AnchorSpec>): LightweightAnchor;
    // (undocumented)
    redraw(elementId: string, timestamp?: string, offsetToUI?: PointXY): RedrawResult;
    // (undocumented)
    reset(): void;
    // @internal
    selectAnchorLocation(a: LightweightAnchor, coords: {
        x: number;
        y: number;
    }): boolean;
    // (undocumented)
    setAnchor(endpoint: Endpoint, anchor: LightweightAnchor): void;
    // (undocumented)
    setAnchorOrientation(anchor: LightweightAnchor, orientation: Orientation): void;
    // (undocumented)
    setConnectionAnchors(conn: Connection<any>, anchors: [LightweightAnchor, LightweightAnchor]): void;
    // @internal (undocumented)
    setCurrentFace(a: LightweightContinuousAnchor, face: Face, overrideLock?: boolean): void;
    // @internal (undocumented)
    unlock(a: LightweightAnchor): void;
    // @internal (undocumented)
    unlockCurrentAxis(a: LightweightContinuousAnchor): void;
}

// Warning: (ae-incompatible-release-tags) The symbol "lineIntersection" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public (undocumented)
export function lineIntersection(connector: ConnectorBase, x1: number, y1: number, x2: number, y2: number): Array<PointXY>;

// @public (undocumented)
export interface ListSpec {
    // (undocumented)
    endpoint?: EndpointSpec;
}

// @public (undocumented)
export function makeLightweightAnchorFromSpec(spec: AnchorSpec | Array<AnchorSpec>): LightweightAnchor;

// @public (undocumented)
export type ManagedElement<E> = {
    el: jsPlumbElement<E>;
    viewportElement?: ViewportElement<E>;
    endpoints?: Array<Endpoint>;
    connections?: Array<Connection>;
    rotation?: number;
    group?: string;
    data: Record<string, Record<string, any>>;
};

// @public
export interface ManageElementParams<E = any> {
    // (undocumented)
    el: E;
}

// @public (undocumented)
export const NONE = "none";

// @public (undocumented)
export type Orientation = [AnchorOrientationHint, AnchorOrientationHint];

// @public (undocumented)
export interface OverlayBase {
    // (undocumented)
    attributes: Record<string, string>;
    // (undocumented)
    component: Component;
    // (undocumented)
    cssClass: string;
    // (undocumented)
    id: string;
    // (undocumented)
    instance: JsPlumbInstance;
    // (undocumented)
    _listeners: Record<string, Array<Function>>;
    // (undocumented)
    location: number | Array<number>;
    // (undocumented)
    type: string;
    // (undocumented)
    visible: boolean;
}

// @public (undocumented)
export const OverlayFactory: {
    get(instance: JsPlumbInstance, name: string, component: Component, params: any): OverlayBase;
    register(name: string, overlay: OverlayHandler<any>): void;
    updateFrom(overlay: OverlayBase, d: any): void;
    draw(overlay: OverlayBase, component: Component, currentConnectionPaintStyle: PaintStyle, absolutePosition?: PointXY): any;
};

// @public (undocumented)
export interface OverlayHandler<OptionsClass> {
    // (undocumented)
    create(instance: JsPlumbInstance, component: Component, options: OptionsClass): OverlayBase;
    // (undocumented)
    draw(overlay: OverlayBase, component: Component, currentConnectionPaintStyle: PaintStyle, absolutePosition?: PointXY): any;
    // (undocumented)
    updateFrom(overlay: OverlayBase, d: any): void;
}

// @public (undocumented)
export interface OverlayMouseEventParams {
    // (undocumented)
    e: Event;
    // (undocumented)
    overlay: OverlayBase;
}

// @public (undocumented)
export const Overlays: {
    setLocation(overlay: OverlayBase, l: number | string): void;
    setVisible(overlay: OverlayBase, v: boolean): void;
};

// Warning: (ae-internal-missing-underscore) The name "PaintGeometry" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface PaintGeometry {
    // (undocumented)
    anchorOrientation?: string;
    // (undocumented)
    endStubX: number;
    // (undocumented)
    endStubY: number;
    // (undocumented)
    h: number;
    // (undocumented)
    isXGreaterThanStubTimes2: boolean;
    // (undocumented)
    isYGreaterThanStubTimes2: boolean;
    // (undocumented)
    mx: number;
    // (undocumented)
    my: number;
    // (undocumented)
    opposite: boolean;
    // (undocumented)
    orthogonal: boolean;
    // (undocumented)
    perpendicular: boolean;
    // (undocumented)
    points: [number, number, number, number, number, number, number, number];
    // (undocumented)
    segment: number;
    // (undocumented)
    so: Orientation;
    // (undocumented)
    sourceAxis: PaintAxis;
    // (undocumented)
    startStubX: number;
    // (undocumented)
    startStubY: number;
    // (undocumented)
    stubs: [number, number];
    // (undocumented)
    sx: number;
    // (undocumented)
    sy: number;
    // (undocumented)
    to: Orientation;
    // (undocumented)
    tx: number;
    // (undocumented)
    ty: number;
    // (undocumented)
    w: number;
    // (undocumented)
    x: number;
    // (undocumented)
    xSpan: number;
    // (undocumented)
    y: number;
    // (undocumented)
    ySpan: number;
}

// @public (undocumented)
export interface PlainArrowOverlay extends ArrowOverlay {
}

// Warning: (ae-incompatible-release-tags) The symbol "pointAlongComponentPathFrom" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public (undocumented)
export function pointAlongComponentPathFrom(connector: ConnectorBase, location: number, distance: number, absolute?: boolean): PointXY;

// Warning: (ae-incompatible-release-tags) The symbol "pointOnComponentPath" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public (undocumented)
export function pointOnComponentPath(connector: ConnectorBase, location: number, absolute?: boolean): PointXY;

// @public (undocumented)
export interface RectangleEndpoint extends EndpointRepresentation<ComputedRectangleEndpoint> {
    // (undocumented)
    height: number;
    // (undocumented)
    width: number;
}

// @public (undocumented)
export const RectangleEndpointHandler: EndpointHandler<RectangleEndpoint, ComputedRectangleEndpoint>;

// @public (undocumented)
export interface RedrawResult {
    // (undocumented)
    c: Set<Connection>;
    // (undocumented)
    e: Set<Endpoint>;
}

// @public
export const REDROP_POLICY_ANY = "any";

// @public
export const REDROP_POLICY_ANY_SOURCE = "anySource";

// @public
export const REDROP_POLICY_ANY_SOURCE_OR_TARGET = "anySourceOrTarget";

// @public
export const REDROP_POLICY_ANY_TARGET = "anyTarget";

// @public
export const REDROP_POLICY_STRICT = "strict";

// @public
export type RedropPolicy = typeof REDROP_POLICY_STRICT | typeof REDROP_POLICY_ANY | typeof REDROP_POLICY_ANY_SOURCE | typeof REDROP_POLICY_ANY_TARGET | typeof REDROP_POLICY_ANY_SOURCE_OR_TARGET;

// @public (undocumented)
export const REMOVE_CLASS_ACTION = "remove";

// @public (undocumented)
export function _removeTypeCssHelper<E>(component: Component, typeId: string): void;

// Warning: (ae-incompatible-release-tags) The symbol "resetBounds" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public (undocumented)
export function resetBounds(connector: ConnectorBase): void;

// Warning: (ae-incompatible-release-tags) The symbol "resetGeometry" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public (undocumented)
export function resetGeometry(connector: ConnectorBase): void;

// @public (undocumented)
export const RIGHT = FaceValues.right;

// @public (undocumented)
export interface Router<T extends {
    E: unknown;
}, A> {
    // (undocumented)
    anchorsEqual(a: A, b: A): boolean;
    // Warning: (ae-incompatible-release-tags) The symbol "computeAnchorLocation" is marked as @public, but its signature references "AnchorComputeParams" which is marked as @internal
    //
    // (undocumented)
    computeAnchorLocation(anchor: A, params: AnchorComputeParams): AnchorPlacement;
    // (undocumented)
    computePath(connection: Connection, timestamp: string): void;
    // Warning: (ae-incompatible-release-tags) The symbol "getEndpointLocation" is marked as @public, but its signature references "AnchorComputeParams" which is marked as @internal
    //
    // (undocumented)
    getEndpointLocation(endpoint: Endpoint, params: AnchorComputeParams): AnchorPlacement;
    // (undocumented)
    getEndpointOrientation(endpoint: Endpoint): Orientation;
    // (undocumented)
    isDynamicAnchor(ep: Endpoint): boolean;
    // (undocumented)
    isFloating(ep: Endpoint): boolean;
    // (undocumented)
    lock(a: A): void;
    // (undocumented)
    prepareAnchor(params: AnchorSpec | Array<AnchorSpec>): A;
    // (undocumented)
    redraw(elementId: string, timestamp?: string, offsetToUI?: PointXY): RedrawResult;
    // (undocumented)
    reset(): void;
    // (undocumented)
    selectAnchorLocation(a: A, coords: {
        x: number;
        y: number;
    }): boolean;
    // (undocumented)
    setAnchor(endpoint: Endpoint, anchor: A): void;
    // (undocumented)
    setAnchorOrientation(anchor: A, orientation: Orientation): void;
    // (undocumented)
    setConnectionAnchors(conn: Connection, anchors: [A, A]): void;
    // (undocumented)
    setCurrentFace(a: LightweightContinuousAnchor, face: Face, overrideLock?: boolean): void;
    // (undocumented)
    unlock(a: A): void;
}

// @public
export const SEGMENT_TYPE_ARC = "Arc";

// @public
export const SEGMENT_TYPE_STRAIGHT = "Straight";

// @public (undocumented)
export interface SegmentHandler<T extends Segment> {
    // (undocumented)
    boundingBoxIntersection(segment: T, box: BoundingBox): Array<PointXY>;
    // (undocumented)
    boxIntersection(s: T, x: number, y: number, w: number, h: number): Array<PointXY>;
    // (undocumented)
    create(segmentType: string, params: any): T;
    // (undocumented)
    findClosestPointOnPath(s: T, x: number, y: number): PointNearPath;
    // (undocumented)
    getLength(s: T): number;
    // (undocumented)
    getPath(s: T, isFirstSegment: boolean): string;
    // (undocumented)
    gradientAtPoint(s: T, location: number, absolute?: boolean): number;
    // (undocumented)
    gradientAtPoint(s: T, location: number, absolute?: boolean): number;
    // (undocumented)
    lineIntersection(s: T, x1: number, y1: number, x2: number, y2: number): Array<PointXY>;
    // (undocumented)
    pointAlongPathFrom(s: T, location: number, distance: number, absolute?: boolean): PointXY;
    // (undocumented)
    pointOnPath(s: T, location: number, absolute?: boolean): PointXY;
}

// @public (undocumented)
export const Segments: {
    register: (segmentType: string, segmentHandler: SegmentHandler<any>) => void;
    get: (segmentType: string) => SegmentHandler<any>;
};

// @public (undocumented)
export interface SelectEndpointOptions<E> extends AbstractSelectOptions<E> {
    // (undocumented)
    element?: ElementSelectionSpecifier<E>;
}

// @public (undocumented)
export type SelectionList = '*' | Array<string>;

// @public (undocumented)
export interface SelectOptions<E> extends AbstractSelectOptions<E> {
    // (undocumented)
    connections?: Array<Connection>;
}

// @public (undocumented)
export const SELECTOR_MANAGED_ELEMENT: string;

// Warning: (ae-incompatible-release-tags) The symbol "setGeometry" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public
export function setGeometry(connector: ConnectorBase, g: Geometry, internal: boolean): void;

// Warning: (ae-internal-missing-underscore) The name "setPreparedConnector" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function setPreparedConnector(connection: Connection, connector: ConnectorBase, doNotRepaint?: boolean, doNotChangeListenerComponent?: boolean, typeId?: string): void;

// @public (undocumented)
export const SOURCE = "source";

// @public (undocumented)
export const SOURCE_INDEX = 0;

// @public
export interface SourceDefinition extends SourceOrTargetDefinition {
}

// @public
export interface SourceOrTargetDefinition {
    // (undocumented)
    def: BehaviouralTypeDescriptor;
    // (undocumented)
    enabled?: boolean;
    // (undocumented)
    endpoint?: Endpoint;
    // (undocumented)
    maxConnections?: number;
    // (undocumented)
    uniqueEndpoint?: boolean;
}

// @public (undocumented)
export const STATIC = "static";

// Warning: (ae-incompatible-release-tags) The symbol "StraightConnector" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public (undocumented)
export interface StraightConnector extends ConnectorBase {
    // (undocumented)
    type: typeof CONNECTOR_TYPE_STRAIGHT;
}

// @public (undocumented)
export interface StraightConnectorGeometry {
    // (undocumented)
    source: AnchorPlacement;
    // (undocumented)
    target: AnchorPlacement;
}

// @public
export interface StraightSegment extends Segment {
    // (undocumented)
    length: number;
    // (undocumented)
    m: number;
    // (undocumented)
    m2: number;
}

// Warning: (ae-internal-missing-underscore) The name "StraightSegmentCoordinates" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type StraightSegmentCoordinates = {
    x1: number;
    y1: number;
    x2: number;
    y2: number;
};

// Warning: (ae-internal-missing-underscore) The name "StraightSegmentParams" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface StraightSegmentParams extends SegmentParams {
}

// @public (undocumented)
export const TARGET = "target";

// @public (undocumented)
export const TARGET_INDEX = 1;

// @public
export interface TargetDefinition extends SourceOrTargetDefinition {
}

// @public (undocumented)
export const TOP = FaceValues.top;

// Warning: (ae-internal-missing-underscore) The name "transformAnchorPlacement" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function transformAnchorPlacement(a: AnchorPlacement, dx: number, dy: number): AnchorPlacement;

// Warning: (ae-internal-missing-underscore) The name "TranslatedViewportElement" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type TranslatedViewportElement<E> = Omit<TranslatedViewportElementBase<E>, "dirty">;

// Warning: (ae-internal-missing-underscore) The name "TranslatedViewportElementBase" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface TranslatedViewportElementBase<E> extends ViewportElementBase<E> {
    // (undocumented)
    cr: number;
    // (undocumented)
    sr: number;
}

// @public (undocumented)
export const TYPE_DESCRIPTOR_CONNECTION = "connection";

// @public (undocumented)
export const TYPE_DESCRIPTOR_CONNECTOR = "connector";

// @public (undocumented)
export const TYPE_DESCRIPTOR_ENDPOINT = "endpoint";

// @public (undocumented)
export const TYPE_DESCRIPTOR_ENDPOINT_REPRESENTATION = "endpoint-representation";

// @public (undocumented)
export const TYPE_ENDPOINT_BLANK = "Blank";

// @public (undocumented)
export const TYPE_ENDPOINT_DOT = "Dot";

// @public (undocumented)
export const TYPE_ENDPOINT_RECTANGLE = "Rectangle";

// @public (undocumented)
export const TYPE_ID_CONNECTION = "_jsplumb_connection";

// Warning: (ae-internal-missing-underscore) The name "TYPE_ITEM_ANCHORS" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const TYPE_ITEM_ANCHORS = "anchors";

// Warning: (ae-internal-missing-underscore) The name "TYPE_ITEM_CONNECTOR" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const TYPE_ITEM_CONNECTOR = "connector";

// @public (undocumented)
export const TYPE_OVERLAY_ARROW = "Arrow";

// @public (undocumented)
export const TYPE_OVERLAY_CUSTOM = "Custom";

// @public (undocumented)
export const TYPE_OVERLAY_DIAMOND = "Diamond";

// @public (undocumented)
export const TYPE_OVERLAY_LABEL = "Label";

// @public (undocumented)
export const TYPE_OVERLAY_PLAIN_ARROW = "PlainArrow";

// @public
export interface TypeDescriptor extends TypeDescriptorBase {
    overlays?: Array<OverlaySpec>;
}

// @public
export interface TypeDescriptorBase {
    anchor?: AnchorSpec;
    anchors?: [AnchorSpec, AnchorSpec];
    connector?: ConnectorSpec;
    connectorClass?: string;
    connectorHoverStyle?: PaintStyle;
    connectorStyle?: PaintStyle;
    cssClass?: string;
    endpoint?: EndpointSpec;
    hoverPaintStyle?: PaintStyle;
    mergeStrategy?: string;
    paintStyle?: PaintStyle;
    parameters?: Record<string, any>;
    scope?: string;
}

// @public (undocumented)
export class UIGroup<E = any> extends UINode<E> {
    constructor(instance: JsPlumbInstance, el: E, options: GroupOptions);
    // (undocumented)
    add(_el: E, doNotFireEvent?: boolean): void;
    // (undocumented)
    addGroup(group: UIGroup<E>): boolean;
    // (undocumented)
    anchor: AnchorSpec;
    // (undocumented)
    children: Array<UINode<E>>;
    // (undocumented)
    collapsed: boolean;
    // (undocumented)
    get collapseParent(): UIGroup<E>;
    // (undocumented)
    readonly connections: {
        source: Array<Connection>;
        target: Array<Connection>;
        internal: Array<Connection>;
    };
    // (undocumented)
    constrain: boolean;
    // (undocumented)
    get contentArea(): any;
    // (undocumented)
    dropOverride: boolean;
    // (undocumented)
    droppable: boolean;
    // (undocumented)
    readonly elId: string;
    // (undocumented)
    enabled: boolean;
    // (undocumented)
    endpoint: EndpointSpec;
    // (undocumented)
    getGroups(): Array<UIGroup<E>>;
    // (undocumented)
    getNodes(): Array<UINode<E>>;
    // (undocumented)
    ghost: boolean;
    // (undocumented)
    id: string;
    // (undocumented)
    instance: JsPlumbInstance;
    // (undocumented)
    manager: GroupManager<E>;
    // (undocumented)
    orphan: boolean;
    // (undocumented)
    orphanAll(): Record<string, PointXY>;
    // (undocumented)
    proxied: boolean;
    // (undocumented)
    prune: boolean;
    // (undocumented)
    remove(el: E, manipulateDOM?: boolean, doNotFireEvent?: boolean, doNotUpdateConnections?: boolean, targetGroup?: UIGroup<E>): void;
    // (undocumented)
    removeAll(manipulateDOM?: boolean, doNotFireEvent?: boolean): void;
    // (undocumented)
    removeGroup(group: UIGroup<E>): void;
    // (undocumented)
    revert: boolean;
}

// @public (undocumented)
export class UINode<E> {
    constructor(instance: JsPlumbInstance, el: E);
    // (undocumented)
    el: E;
    // (undocumented)
    group: UIGroup<E>;
    // (undocumented)
    instance: JsPlumbInstance;
}

// @public
export interface UnmanageElementParams<E = any> {
    // (undocumented)
    el: E;
}

// Warning: (ae-incompatible-release-tags) The symbol "updateBounds" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public (undocumented)
export function updateBounds(connector: ConnectorBase, segment: Segment): void;

// @public (undocumented)
export function _updateHoverStyle<E>(component: Component): void;

// Warning: (ae-internal-missing-underscore) The name "UpdateOffsetOptions" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface UpdateOffsetOptions {
    // (undocumented)
    elId?: string;
    // (undocumented)
    recalc?: boolean;
    // (undocumented)
    timestamp?: string;
}

// Warning: (ae-incompatible-release-tags) The symbol "_updateSegmentProportions" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
//
// @public (undocumented)
export function _updateSegmentProportions(connector: ConnectorBase): void;

// @public (undocumented)
export type UUID = string;

// @public
export class Viewport<T extends {
    E: unknown;
}> extends EventGenerator {
    constructor(instance: JsPlumbInstance<T>);
    // Warning: (ae-incompatible-release-tags) The symbol "addElement" is marked as @public, but its signature references "ViewportElement" which is marked as @internal
    addElement(id: string, x: number, y: number, width: number, height: number, rotation: number): ViewportElement<T["E"]>;
    // (undocumented)
    _bounds: Record<string, number>;
    // Warning: (ae-incompatible-release-tags) The symbol "_elementMap" is marked as @public, but its signature references "ViewportElement" which is marked as @internal
    //
    // (undocumented)
    _elementMap: Map<string, ViewportElement<T["E"]>>;
    // (undocumented)
    endTransaction(): void;
    getBoundsHeight(): number;
    getBoundsWidth(): number;
    // Warning: (ae-incompatible-release-tags) The symbol "getElements" is marked as @public, but its signature references "ViewportElement" which is marked as @internal
    getElements(): Map<string, ViewportElement<T["E"]>>;
    // (undocumented)
    protected getOffset(el: T["E"]): PointXY;
    // Warning: (ae-incompatible-release-tags) The symbol "getPosition" is marked as @public, but its signature references "ViewportElement" which is marked as @internal
    getPosition(id: string): ViewportElement<T["E"]>;
    // (undocumented)
    protected getSize(el: T["E"]): Size;
    getX(): number;
    getY(): number;
    // (undocumented)
    instance: JsPlumbInstance<T>;
    isEmpty(): boolean;
    // (undocumented)
    recomputeBounds(): void;
    // Warning: (ae-incompatible-release-tags) The symbol "refreshElement" is marked as @public, but its signature references "ViewportElement" which is marked as @internal
    refreshElement(elId: string, doNotRecalculateBounds?: boolean): ViewportElement<T["E"]>;
    // Warning: (ae-incompatible-release-tags) The symbol "registerElement" is marked as @public, but its signature references "ViewportElement" which is marked as @internal
    registerElement(id: string, doNotRecalculateBounds?: boolean): ViewportElement<T["E"]>;
    remove(id: string): void;
    reset(): void;
    // Warning: (ae-incompatible-release-tags) The symbol "rotateElement" is marked as @public, but its signature references "ViewportElement" which is marked as @internal
    rotateElement(id: string, rotation: number): ViewportElement<T["E"]>;
    // Warning: (ae-incompatible-release-tags) The symbol "setPosition" is marked as @public, but its signature references "ViewportElement" which is marked as @internal
    setPosition(id: string, x: number, y: number): ViewportElement<T["E"]>;
    // Warning: (ae-incompatible-release-tags) The symbol "setSize" is marked as @public, but its signature references "ViewportElement" which is marked as @internal
    setSize(id: string, w: number, h: number): ViewportElement<T["E"]>;
    // (undocumented)
    shouldFireEvent(event: string, value: unknown, originalEvent?: Event): boolean;
    // (undocumented)
    _sortedElements: Record<string, Array<[string, number]>>;
    // (undocumented)
    startTransaction(): void;
    // Warning: (ae-incompatible-release-tags) The symbol "_transformedElementMap" is marked as @public, but its signature references "TranslatedViewportElement" which is marked as @internal
    //
    // (undocumented)
    _transformedElementMap: Map<string, TranslatedViewportElement<T["E"]>>;
    // Warning: (ae-incompatible-release-tags) The symbol "updateElement" is marked as @public, but its signature references "ViewportElement" which is marked as @internal
    updateElement(id: string, x: number, y: number, width: number, height: number, rotation: number, doNotRecalculateBounds?: boolean): ViewportElement<T["E"]>;
    // (undocumented)
    updateElements(entries: Array<{
        id: string;
        x: number;
        y: number;
        width: number;
        height: number;
        rotation: number;
    }>): void;
}

// Warning: (ae-internal-missing-underscore) The name "ViewportElement" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface ViewportElement<E> extends ViewportElementBase<E> {
    // (undocumented)
    t: TranslatedViewportElement<E>;
}

// Warning: (ae-internal-missing-underscore) The name "ViewportElementBase" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface ViewportElementBase<E> extends ViewportPosition {
    // (undocumented)
    dirty: boolean;
    // (undocumented)
    x2: number;
    // (undocumented)
    y2: number;
}

// @public
export interface ViewportPosition extends PointXY {
    // (undocumented)
    c: PointXY;
    // (undocumented)
    h: number;
    // (undocumented)
    r: number;
    // (undocumented)
    w: number;
}

// @public (undocumented)
export const X_AXIS_FACES: Axis;

// @public (undocumented)
export const Y_AXIS_FACES: Axis;

// Warnings were encountered during analysis:
//
// /Users/simon/programming/jsplumb/jsplumb/dist/core/types/connector/abstract-connector.d.ts:29:5 - (ae-incompatible-release-tags) The symbol "sourceInfo" is marked as @public, but its signature references "ViewportElement" which is marked as @internal
// /Users/simon/programming/jsplumb/jsplumb/dist/core/types/connector/abstract-connector.d.ts:30:5 - (ae-incompatible-release-tags) The symbol "targetInfo" is marked as @public, but its signature references "ViewportElement" which is marked as @internal
// /Users/simon/programming/jsplumb/jsplumb/dist/core/types/connector/connectors.d.ts:26:5 - (ae-incompatible-release-tags) The symbol "exportGeometry" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
// /Users/simon/programming/jsplumb/jsplumb/dist/core/types/connector/connectors.d.ts:32:5 - (ae-incompatible-release-tags) The symbol "importGeometry" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
// /Users/simon/programming/jsplumb/jsplumb/dist/core/types/connector/connectors.d.ts:82:5 - (ae-incompatible-release-tags) The symbol "setAnchorOrientation" is marked as @public, but its signature references "ConnectorBase" which is marked as @internal
// /Users/simon/programming/jsplumb/jsplumb/dist/core/types/core.d.ts:68:5 - (ae-incompatible-release-tags) The symbol "viewportElement" is marked as @public, but its signature references "ViewportElement" which is marked as @internal

```
